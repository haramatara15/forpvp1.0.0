<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>戦術対抗戦S10　配置確認 1.7.1</title>
<style>
  body { text-align:center; font-family:sans-serif; margin:0; padding:0; }

  /* PCではキャンバスと座標欄を横並び */
  .mainArea {
    display:flex;
    justify-content:center;
    align-items:flex-start;
    gap:20px;
    margin-top:20px;
  }

  canvas {
    border:1px solid #333;
    touch-action:none;
    background-size:cover;
  }

  button {
    margin:5px;
    padding:12px 20px;
    font-size:16px;
  }

  #counter {
    margin-top:10px;
    font-size:18px;
  }

  .max { color:red; font-weight:bold; }

  #coordPanel {
    text-align:left;
    padding:10px;
    border:1px solid #aaa;
    border-radius:8px;
    background:#fafafa;
    width:260px;
  }

  #coordPanel input {
    width:70px;
    margin:3px;
  }

  .description {
    width:90%;
    max-width:900px;
    margin:30px auto;
    text-align:left;
    line-height:1.6;
  }

  /* スマホでは縦並び */
  @media (max-width: 900px) {
    .mainArea {
      flex-direction:column;
      align-items:center;
    }
    #coordPanel {
      width:90%;
    }
  }
</style>
</head>
<body>

<h2>戦術対抗戦S10　配置確認 1.7.1</h2>

<button id="toggleColor">現在：赤 → 青に切替</button>
<button id="toggleLine">線の表示 ON/OFF</button>
<button id="reset">リセット</button>
<button id="saveImage">画像保存</button>

<br>

<button id="modeToggle">①SP攻撃の対象</button>

<div id="counter">
  赤: <span id="redCount">0</span> / 4　
  青: <span id="blueCount">0</span> / 4
</div>

<!-- PCでは横並び、スマホでは縦並び -->
<div class="mainArea">

  <!-- キャンバス（左側） -->
  <div style="flex-shrink:0;">
    <canvas id="board"></canvas>
  </div>

  <!-- 座標入力パネル（右側） -->
  <div id="coordPanel">
    <h3>座標一覧 / 編集（中央原点）</h3>
    <div id="coordList"></div>
    <button id="applyCoords">座標を反映</button>
  </div>

</div>

<!-- 説明テキスト（最下段） -->
<div class="description">
  <h3>ツールの使い方</h3>

  <p>このツールは、戦術対抗戦の部隊配置を視覚的に確認するためのものです。</p>

  <p><strong>● 点の操作</strong></p>
  <ul>
    <li>左クリック / タップ：点を追加</li>
    <li>右クリック / 長押し：点を削除</li>
    <li>ドラッグ / スワイプ：点を移動</li>
    <li>ダブルクリック / ダブルタップ：STバフの基準点を選択</li>
  </ul>

  <p><strong>● モード説明</strong></p>
  <ul>
    <li>① SP攻撃：重心 → 異色の最短点</li>
    <li>② SPバフ：重心 → 同色の最短点</li>
    <li>③ STバフ：選択点 → 同色の最短点（自分を除外）</li>
  </ul>

  <p><strong>● 座標入力について</strong></p>
  <p>座標欄では、キャンバス中央を原点（0,0）として座標を入力できます。</p>
</div>

<script>
const canvas = document.getElementById("board");
const ctx = canvas.getContext("2d");

const bg = new Image();
bg.src = "background.png";

let mode = "red";
let showLines = true;

let redPoints = [];
let bluePoints = [];

let dragging = false;
let dragTarget = null;

let modeType = 1;
let selectedPoint = null;

let lastTapTime = 0;
let longPressTimer = null;

// ===== Canvas 自動リサイズ =====
function resizeCanvas() {
  const w = Math.min(window.innerWidth * 0.9, 800);
  canvas.width = w;
  canvas.height = w / 2;
  draw();
  updateCoordPanel();
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

// ===== PC操作 =====
canvas.addEventListener("mousedown", (e) => {
  const {x, y} = getPos(e);

  dragTarget = findPoint(x, y);
  if (dragTarget) {
    dragging = true;
    return;
  }

  addPoint(x, y);
});

canvas.addEventListener("mousemove", (e) => {
  if (!dragging || !dragTarget) return;
  const {x, y} = getPos(e);
  dragTarget.x = x;
  dragTarget.y = y;
  draw();
  updateCoordPanel();
});

canvas.addEventListener("mouseup", () => {
  dragging = false;
  dragTarget = null;
});

canvas.addEventListener("dblclick", (e) => {
  const {x, y} = getPos(e);
  setSelectedPoint(x, y);
});

// 右クリック削除
canvas.addEventListener("contextmenu", (e) => {
  e.preventDefault();
  const {x, y} = getPos(e);
  deletePoint(x, y);
});

// ===== スマホ操作 =====
canvas.addEventListener("touchstart", (e) => {
  const {x, y} = getPos(e.touches[0]);

  const now = Date.now();
  if (now - lastTapTime < 300) {
    setSelectedPoint(x, y);
    lastTapTime = 0;
    return;
  }
  lastTapTime = now;

  dragTarget = findPoint(x, y);
  if (dragTarget) {
    dragging = true;
  } else {
    longPressTimer = setTimeout(() => deletePoint(x, y), 500);
  }
});

canvas.addEventListener("touchmove", (e) => {
  if (!dragging || !dragTarget) return;
  const {x, y} = getPos(e.touches[0]);
  dragTarget.x = x;
  dragTarget.y = y;
  draw();
  updateCoordPanel();
});

canvas.addEventListener("touchend", (e) => {
  clearTimeout(longPressTimer);
  if (!dragging) {
    const {x, y} = getPos(e.changedTouches[0]);
    addPoint(x, y);
  }
  dragging = false;
  dragTarget = null;
});

// ===== 共通処理 =====
function getPos(e) {
  const rect = canvas.getBoundingClientRect();
  return { x: e.clientX - rect.left, y: e.clientY - rect.top };
}

function findPoint(x, y) {
  for (const p of redPoints) if (dist(p, {x,y}) < 12) return p;
  for (const p of bluePoints) if (dist(p, {x,y}) < 12) return p;
  return null;
}

function addPoint(x, y) {
  if (mode === "red" && redPoints.length < 4) redPoints.push({x,y});
  if (mode === "blue" && bluePoints.length < 4) bluePoints.push({x,y});
  updateCounter();
  draw();
  updateCoordPanel();
}

function deletePoint(x, y) {
  redPoints = redPoints.filter(p => dist(p, {x,y}) >= 12);
  bluePoints = bluePoints.filter(p => dist(p, {x,y}) >= 12);
  updateCounter();
  draw();
  updateCoordPanel();
}

function setSelectedPoint(x, y) {
  for (const p of redPoints) if (dist(p, {x,y}) < 12) { selectedPoint = {...p, color:"red"}; draw(); updateCoordPanel(); return; }
  for (const p of bluePoints) if (dist(p, {x,y}) < 12) { selectedPoint = {...p, color:"blue"}; draw(); updateCoordPanel(); return; }
}

function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }

function centroid(list) {
  if (list.length === 0) return null;
  return {
    x: list.reduce((s,p)=>s+p.x,0) / list.length,
    y: list.reduce((s,p)=>s+p.y,0) / list.length
  };
}

function nearest(from, list, excludeSelf=false) {
  let best = null, bestDist = Infinity;
  for (const p of list) {
    if (excludeSelf && p.x === from.x && p.y === from.y) continue;
    const d = dist(from, p);
    if (d < bestDist) { bestDist = d; best = p; }
  }
  return best;
}

function updateCounter() {
  redCount.textContent = redPoints.length;
  blueCount.textContent = bluePoints.length;
  redCount.className = redPoints.length === 4 ? "max" : "";
  blueCount.className = bluePoints.length === 4 ? "max" : "";
}
// ===== 座標パネル更新（内部 → 中央原点） =====
function updateCoordPanel() {
  const panel = document.getElementById("coordList");
  panel.innerHTML = "";

  const cx = canvas.width / 2;
  const cy = canvas.height / 2;

  function addRow(color, index, point) {
    const id = `${color}${index}`;
    let x = "";
    let y = "";

    if (point) {
      x = Math.round(point.x - cx);
      y = Math.round(point.y - cy);
    }

    panel.innerHTML += `
      <div>
        ${color === "red" ? "赤" : "青"}${index}：
        X <input type="number" id="${id}_x" value="${x}">
        Y <input type="number" id="${id}_y" value="${y}">
      </div>
    `;
  }

  for (let i = 1; i <= 4; i++) addRow("red", i, redPoints[i-1]);
  for (let i = 1; i <= 4; i++) addRow("blue", i, bluePoints[i-1]);
}

// ===== 座標反映（中央原点 → 内部） =====
document.getElementById("applyCoords").onclick = () => {
  const cx = canvas.width / 2;
  const cy = canvas.height / 2;

  function apply(color) {
    const newList = [];
    for (let i = 1; i <= 4; i++) {
      const x = document.getElementById(`${color}${i}_x`).value;
      const y = document.getElementById(`${color}${i}_y`).value;

      if (x !== "" && y !== "") {
        newList.push({
          x: Number(x) + cx,
          y: Number(y) + cy
        });
      }
    }
    return newList;
  }

  redPoints = apply("red");
  bluePoints = apply("blue");

  updateCounter();
  draw();
  updateCoordPanel();
};

// ===== 描画 =====
function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(bg, 0, 0, canvas.width, canvas.height);

  // 赤点
  for (let i = 0; i < redPoints.length; i++) {
    const p = redPoints[i];
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.arc(p.x, p.y, 10, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "white";
    ctx.font = "14px sans-serif";
    ctx.fillText(i+1, p.x-4, p.y+5);
  }

  // 青点
  for (let i = 0; i < bluePoints.length; i++) {
    const p = bluePoints[i];
    ctx.fillStyle = "blue";
    ctx.beginPath();
    ctx.arc(p.x, p.y, 10, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "white";
    ctx.font = "14px sans-serif";
    ctx.fillText(i+1, p.x-4, p.y+5);
  }

  const cRed = centroid(redPoints);
  const cBlue = centroid(bluePoints);

  if (cRed) drawCross(cRed.x, cRed.y, 10, "pink");
  if (cBlue) drawCross(cBlue.x, cBlue.y, 10, "lightblue");

  // ===== モード別ターゲット表示 =====

  // ① SP攻撃（重心→異色）
  if (modeType === 1) {
    if (cRed) {
      const t = nearest(cRed, bluePoints);
      if (t) drawCircle(t.x, t.y, "pink");
    }
    if (cBlue) {
      const t = nearest(cBlue, redPoints);
      if (t) drawCircle(t.x, t.y, "lightblue");
    }
  }

  // ② SPバフ（重心→同色）
  if (modeType === 2) {
    if (cRed) {
      const t = nearest(cRed, redPoints);
      if (t) drawCircle(t.x, t.y, "rgba(255,150,150,0.5)");
    }
    if (cBlue) {
      const t = nearest(cBlue, bluePoints);
      if (t) drawCircle(t.x, t.y, "rgba(100,150,255,0.5)");
    }
  }

  // ③ STバフ（基準点→同色）
  if (modeType === 3 && selectedPoint) {
    drawCross(selectedPoint.x, selectedPoint.y, 12, "yellow");

    if (selectedPoint.color === "red") {
      const t = nearest(selectedPoint, redPoints, true);
      if (t) drawCircle(t.x, t.y, "rgba(255,150,150,0.5)");
    }

    if (selectedPoint.color === "blue") {
      const t = nearest(selectedPoint, bluePoints, true);
      if (t) drawCircle(t.x, t.y, "rgba(100,150,255,0.5)");
    }
  }
  // ===== 機能4：扇形の描画（異色の最寄り点方向） =====
if (modeType === 3 && selectedPoint) {
  const p = selectedPoint;

  // 扇形の色（薄い赤 or 薄い青）
  const fillColor = p.color === "red"
    ? "rgba(255,0,0,0.3)"
    : "rgba(0,0,255,0.3)";

  // 扇形の設定
  const radius = 180;
  const angle = Math.PI / 3; // 60°
  const half = angle / 2;

  // 異色の点リスト
  const enemyList = p.color === "red" ? bluePoints : redPoints;

  // 異色の最寄り点
  const t = nearest(p, enemyList);

  // 向き（基準点 → 異色最寄り点）
  let baseAngle = 0;
  if (t) {
    baseAngle = Math.atan2(t.y - p.y, t.x - p.x);
  }

  const startAngle = baseAngle - half;
  const endAngle = baseAngle + half;

  // 扇形描画
  ctx.beginPath();
  ctx.moveTo(p.x, p.y);
  ctx.arc(p.x, p.y, radius, startAngle, endAngle);
  ctx.closePath();

  ctx.fillStyle = fillColor;
  ctx.fill();
  }
  
  // 線表示（SP攻撃のみ）
  if (showLines && modeType === 1) {
    if (cRed) {
      const t = nearest(cRed, bluePoints);
      if (t) {
        ctx.strokeStyle = "purple";
        ctx.beginPath();
        ctx.moveTo(cRed.x, cRed.y);
        ctx.lineTo(t.x, t.y);
        ctx.stroke();
      }
    }
    if (cBlue) {
      const t = nearest(cBlue, redPoints);
      if (t) {
        ctx.strokeStyle = "green";
        ctx.beginPath();
        ctx.moveTo(cBlue.x, cBlue.y);
        ctx.lineTo(t.x, t.y);
        ctx.stroke();
      }
    }
  }
}

function drawCross(x, y, size, color) {
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x-size, y-size);
  ctx.lineTo(x+size, y+size);
  ctx.moveTo(x+size, y-size);
  ctx.lineTo(x-size, y+size);
  ctx.stroke();
}

function drawCircle(x, y, color) {
  ctx.strokeStyle = color;
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.arc(x, y, 16, 0, Math.PI*2);
  ctx.stroke();
}

// ===== ボタン処理 =====
document.getElementById("modeToggle").onclick = () => {
  modeType = (modeType % 3) + 1;
  selectedPoint = null;

  const btn = document.getElementById("modeToggle");
  if (modeType === 1) btn.textContent = "①SP攻撃の対象";
  if (modeType === 2) btn.textContent = "②SPバフの対象";
  if (modeType === 3) btn.textContent = "③STバフの対象";

  draw();
};

document.getElementById("toggleColor").onclick = () => {
  mode = (mode === "red") ? "blue" : "red";
  document.getElementById("toggleColor").textContent =
    `現在：${mode === "red" ? "赤" : "青"} → ${mode === "red" ? "青" : "赤"}に切替`;
};

document.getElementById("toggleLine").onclick = () => {
  showLines = !showLines;
  draw();
};

document.getElementById("reset").onclick = () => {
  redPoints = [];
  bluePoints = [];
  selectedPoint = null;
  updateCounter();
  draw();
  updateCoordPanel();
};

// ===== 画像保存 =====
document.getElementById("saveImage").onclick = () => {
  const link = document.createElement("a");
  link.download = "tactics.png";
  link.href = canvas.toDataURL("image/png");
  link.click();
};

bg.onload = () => {
  draw();
  updateCoordPanel();
};
</script>

</body>
</html>
