<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>戦術対抗戦S10　配置確認 1.4.0</title>
<style>
  body { text-align:center; font-family:sans-serif; margin:0; padding:0; }

  canvas {
    border:1px solid #333;
    touch-action:none;
    background-size:cover;
  }

  button {
    margin:5px;
    padding:12px 20px;
    font-size:16px;
  }

  #counter {
    margin-top:10px;
    font-size:18px;
  }

  .max { color:red; font-weight:bold; }

  .container {
    display:flex;
    justify-content:center;
    align-items:flex-start;
    gap:20px;
    margin-top:10px;
  }

  .description {
    width:260px;
    text-align:left;
    font-size:16px;
    line-height:1.5;
  }

  /* スマホでは縦並びにする */
  @media (max-width: 900px) {
    .container {
      flex-direction:column;
      align-items:center;
    }
    .description {
      width:90%;
    }
  }
</style>
</head>
<body>

<h2>戦術対抗戦S10　配置確認 1.4.0</h2>

<button id="toggleColor">現在：赤 → 青に切替</button>
<button id="toggleLine">線の表示 ON/OFF</button>
<button id="reset">リセット</button>
<button id="saveImage">画像保存</button>

<br>

<button id="modeToggle">①SP攻撃の対象</button>

<div id="counter">
  赤: <span id="redCount">0</span> / 4　
  青: <span id="blueCount">0</span> / 4
</div>

<div class="container">

  <canvas id="board"></canvas>

  <div class="description">
    <p>左クリック（タップ）でプロット、右クリック（長押し）で削除できます。</p>
    <p>ドラッグ（スワイプ）すると置いた点を動かせます。</p>
    <p>バツ印が部隊中央、丸で囲まれた点がターゲットを表します。</p>
    <p>モード切替：</p>
    <ul>
      <li>①SP攻撃：重心→異色の最短点</li>
      <li>②SPバフ：重心→同色の最短点</li>
      <li>③STバフ：ダブルタップした点→同色の最短点</li>
    </ul>
  </div>

</div>

<script>
const canvas = document.getElementById("board");
const ctx = canvas.getContext("2d");

const bg = new Image();
bg.src = "background.png";

let mode = "red";
let showLines = true;

let redPoints = [];
let bluePoints = [];

let dragging = false;
let dragTarget = null;

let modeType = 1;
let selectedPoint = null;

let lastTapTime = 0;
let longPressTimer = null;

// ===== Canvas 自動リサイズ =====
function resizeCanvas() {
  const w = Math.min(window.innerWidth * 0.9, 800);
  canvas.width = w;
  canvas.height = w / 2;
  draw();
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

// ===== PC操作 =====
canvas.addEventListener("mousedown", (e) => {
  const {x, y} = getPos(e);

  dragTarget = findPoint(x, y);
  if (dragTarget) {
    dragging = true;
    return;
  }

  addPoint(x, y);
});

canvas.addEventListener("mousemove", (e) => {
  if (!dragging || !dragTarget) return;
  const {x, y} = getPos(e);
  dragTarget.x = x;
  dragTarget.y = y;
  draw();
});

canvas.addEventListener("mouseup", () => {
  dragging = false;
  dragTarget = null;
});

canvas.addEventListener("dblclick", (e) => {
  const {x, y} = getPos(e);
  setSelectedPoint(x, y);
});

// 右クリック削除
canvas.addEventListener("contextmenu", (e) => {
  e.preventDefault();
  const {x, y} = getPos(e);
  deletePoint(x, y);
});

// ===== スマホ操作 =====
canvas.addEventListener("touchstart", (e) => {
  const {x, y} = getPos(e.touches[0]);

  // ダブルタップ判定
  const now = Date.now();
  if (now - lastTapTime < 300) {
    setSelectedPoint(x, y);
    lastTapTime = 0;
    return;
  }
  lastTapTime = now;

  dragTarget = findPoint(x, y);
  if (dragTarget) {
    dragging = true;
  } else {
    longPressTimer = setTimeout(() => deletePoint(x, y), 500);
  }
});

canvas.addEventListener("touchmove", (e) => {
  if (!dragging || !dragTarget) return;
  const {x, y} = getPos(e.touches[0]);
  dragTarget.x = x;
  dragTarget.y = y;
  draw();
});

canvas.addEventListener("touchend", (e) => {
  clearTimeout(longPressTimer);
  if (!dragging) {
    const {x, y} = getPos(e.changedTouches[0]);
    addPoint(x, y);
  }
  dragging = false;
  dragTarget = null;
});

// ===== 共通処理 =====
function getPos(e) {
  const rect = canvas.getBoundingClientRect();
  return { x: e.clientX - rect.left, y: e.clientY - rect.top };
}

function findPoint(x, y) {
  for (const p of redPoints) if (dist(p, {x,y}) < 12) return p;
  for (const p of bluePoints) if (dist(p, {x,y}) < 12) return p;
  return null;
}

function addPoint(x, y) {
  if (mode === "red" && redPoints.length < 4) redPoints.push({x,y});
  if (mode === "blue" && bluePoints.length < 4) bluePoints.push({x,y});
  updateCounter();
  draw();
}

function deletePoint(x, y) {
  redPoints = redPoints.filter(p => dist(p, {x,y}) >= 12);
  bluePoints = bluePoints.filter(p => dist(p, {x,y}) >= 12);
  updateCounter();
  draw();
}

function setSelectedPoint(x, y) {
  for (const p of redPoints) if (dist(p, {x,y}) < 12) { selectedPoint = {...p, color:"red"}; draw(); return; }
  for (const p of bluePoints) if (dist(p, {x,y}) < 12) { selectedPoint = {...p, color:"blue"}; draw(); return; }
}

function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }

function centroid(list) {
  if (list.length === 0) return null;
  return {
    x: list.reduce((s,p)=>s+p.x,0) / list.length,
    y: list.reduce((s,p)=>s+p.y,0) / list.length
  };
}

function nearest(from, list, excludeSelf=false) {
  let best = null, bestDist = Infinity;
  for (const p of list) {
    if (excludeSelf && p.x === from.x && p.y === from.y) continue;
    const d = dist(from, p);
    if (d < bestDist) { bestDist = d; best = p; }
  }
  return best;
}

function updateCounter() {
  redCount.textContent = redPoints.length;
  blueCount.textContent = bluePoints.length;
  redCount.className = redPoints.length === 4 ? "max" : "";
  blueCount.className = bluePoints.length === 4 ? "max" : "";
}

function drawCross(x, y, size, color) {
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x-size, y-size);
  ctx.lineTo(x+size, y+size);
  ctx.moveTo(x+size, y-size);
  ctx.lineTo(x-size, y+size);
  ctx.stroke();
}

function drawCircle(x, y, color) {
  ctx.strokeStyle = color;
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.arc(x, y, 16, 0, Math.PI*2);
  ctx.stroke();
}

// ===== 描画 =====
function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(bg, 0, 0, canvas.width, canvas.height);

  for (const p of redPoints) {
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.arc(p.x, p.y, 10, 0, Math.PI*2);
    ctx.fill();
  }
  for (const p of bluePoints) {
    ctx.fillStyle = "blue";
    ctx.beginPath();
    ctx.arc(p.x, p.y, 10, 0, Math.PI*2);
    ctx.fill();
  }

  const cRed = centroid(redPoints);
  const cBlue = centroid(bluePoints);

  if (cRed) drawCross(cRed.x, cRed.y, 10, "pink");
  if (cBlue) drawCross(cBlue.x, cBlue.y, 10, "lightblue");

  // ===== モード別ターゲット表示 =====

  // ① SP攻撃（重心→異色）
  if (modeType === 1) {
    if (cRed) {
      const t = nearest(cRed, bluePoints);
      if (t) drawCircle(t.x, t.y, "pink");
    }
    if (cBlue) {
      const t = nearest(cBlue, redPoints);
      if (t) drawCircle(t.x, t.y, "lightblue");
    }
  }

  // ② SPバフ（重心→同色）
  if (modeType === 2) {
    if (cRed) {
      const t = nearest(cRed, redPoints);
      if (t) drawCircle(t.x, t.y, "rgba(255,150,150,0.5)");
    }
    if (cBlue) {
      const t = nearest(cBlue, bluePoints);
      if (t) drawCircle(t.x, t.y, "rgba(100,150,255,0.5)");
    }
  }

  // ③ STバフ（基準点→同色、自分自身を除外）
  if (modeType === 3 && selectedPoint) {
    drawCross(selectedPoint.x, selectedPoint.y, 12, "yellow");

    if (selectedPoint.color === "red") {
      const t = nearest(selectedPoint, redPoints, true);
      if (t) drawCircle(t.x, t.y, "rgba(255,150,150,0.5)");
    }

    if (selectedPoint.color === "blue") {
      const t = nearest(selectedPoint, bluePoints, true);
      if (t) drawCircle(t.x, t.y, "rgba(100,150,255,0.5)");
    }
  }

  // 線表示（SP攻撃のみ）
  if (showLines && modeType === 1) {
    if (cRed) {
      const t = nearest(cRed, bluePoints);
      if (t) {
        ctx.strokeStyle = "purple";
        ctx.beginPath();
        ctx.moveTo(cRed.x, cRed.y);
        ctx.lineTo(t.x, t.y);
        ctx.stroke();
      }
    }
    if (cBlue) {
      const t = nearest(cBlue, redPoints);
      if (t) {
        ctx.strokeStyle = "green";
        ctx.beginPath();
        ctx.moveTo(cBlue.x, cBlue.y);
        ctx.lineTo(t.x, t.y);
        ctx.stroke();
      }
    }
  }
}

// ===== ボタン処理 =====
document.getElementById("modeToggle").onclick = () => {
  modeType = (modeType % 3) + 1;
  selectedPoint = null;

  const btn = document.getElementById("modeToggle");
  if (modeType === 1) btn.textContent = "①SP攻撃の対象";
  if (modeType === 2) btn.textContent = "②SPバフの対象";
  if (modeType === 3) btn.textContent = "③STバフの対象";

  draw();
};

document.getElementById("toggleColor").onclick = () => {
  mode = (mode === "red") ? "blue" : "red";
  document.getElementById("toggleColor").textContent =
    `現在：${mode === "red" ? "赤" : "青"} → ${mode === "red" ? "青" : "赤"}に切替`;
};

document.getElementById("toggleLine").onclick = () => {
  showLines = !showLines;
  draw();
};

document.getElementById("reset").onclick = () => {
  redPoints = [];
  bluePoints = [];
  selectedPoint = null;
  updateCounter();
  draw();
};

// ===== 画像保存 =====
document.getElementById("saveImage").onclick = () => {
  const link = document.createElement("a");
  link.download = "tactics.png";
  link.href = canvas.toDataURL("image/png");
  link.click();
};

bg.onload = () => draw();
</script>

</body>
</html>
