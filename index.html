<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>戦術対抗戦S10　配置確認 2.1.0</title>
<style>
  body { text-align:center; font-family:sans-serif; margin:0; padding:0; }

  .mainArea {
    display:flex;
    justify-content:center;
    align-items:flex-start;
    gap:20px;
    margin-top:20px;
  }

  canvas {
    border:1px solid #333;
    touch-action:none;
    background-size:cover;
  }

  button {
    margin:5px;
    padding:12px 20px;
    font-size:16px;
  }

  #counter {
    margin-top:10px;
    font-size:18px;
  }

  .max { color:red; font-weight:bold; }

  #coordPanel {
    text-align:left;
    padding:10px;
    border:1px solid #aaa;
    border-radius:8px;
    background:#fafafa;
    width:260px;
  }

  #coordPanel input {
    width:80px;
    margin:3px;
  }

  .description {
    width:90%;
    max-width:900px;
    margin:30px auto;
    text-align:left;
    line-height:1.6;
  }

  @media (max-width: 900px) {
    .mainArea {
      flex-direction:column;
      align-items:center;
    }
    #coordPanel {
      width:90%;
    }
  }
</style>
</head>
<body>

<h2>戦術対抗戦S10　配置確認 2.1.0</h2>

<button id="toggleColor">現在：赤 → 青に切替</button>
<button id="toggleLine">線の表示 ON/OFF</button>
<button id="reset">リセット</button>
<button id="saveImage">画像保存</button>

<br>

<!-- ★ 機能1・2の切り替えはボタンのまま -->
<button id="modeToggle">① SP用</button>

<!-- ★ サブ機能はプルダウン -->
<select id="subSelect" style="margin-left:10px;">
  <option value="sp_attack">攻撃SP</option>
  <option value="sp_buff">バフSP</option>
</select>

<div id="counter">
  赤: <span id="redCount">0</span> / 4　
  青: <span id="blueCount">0</span> / 4
</div>

<div class="mainArea">
  <div style="flex-shrink:0;">
    <canvas id="board"></canvas>
  </div>

  <div id="coordPanel">
    <h3>座標一覧 / 編集（中央原点）</h3>
    <div id="coordList"></div>
    <button id="applyCoords">座標を反映</button>
  </div>
</div>

<div class="description">
  <h3>ツールの使い方</h3>
  <p>このツールは、戦術対抗戦の部隊配置を視覚的に確認するためのものです。</p>

  <p><strong>● 点の操作</strong></p>
  <ul>
    <li>左クリック / タップ：点を追加</li>
    <li>右クリック / 長押し：点を削除</li>
    <li>ドラッグ / スワイプ：点を移動</li>
    <li>ダブルクリック / ダブルタップ：ST用の基準点を選択</li>
  </ul>

  <p><strong>● 機能構成</strong></p>
  <ul>
    <li>① SP用
      <ul>
        <li>攻撃SP：重心 → 異色の最短点</li>
        <li>バフSP：重心 → 同色の最短点</li>
      </ul>
    </li>
    <li>② ST用
      <ul>
        <li>バッファー：選択点 → 同色の最短点（円で強調）</li>
        <li>ハナコ（水着）：選択点 → 異色の最短点方向に扇形</li>
      </ul>
    </li>
  </ul>
</div>

<script>
const canvas = document.getElementById("board");
const ctx = canvas.getContext("2d");

const bg = new Image();
bg.src = "background.png";

let mode = "red";
let showLines = true;

let redPoints = [];
let bluePoints = [];

let dragging = false;
let dragTarget = null;

let selectedPoint = null;

// ★ 機能1・2
let modeCategory = 1; // 1=SP用, 2=ST用

// ★ サブ機能
let spMode = "sp_attack";
let stMode = "st_buffer";

let lastTapTime = 0;
let longPressTimer = null;

function resizeCanvas() {
  const w = Math.min(window.innerWidth * 0.9, 800);
  canvas.width = w;
  canvas.height = w / 2;
  draw();
  updateCoordPanel();
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

// ===== マウス・タッチ操作 =====
canvas.addEventListener("mousedown", (e) => {
  const {x, y} = getPos(e);
  dragTarget = findPoint(x, y);
  if (dragTarget) { dragging = true; return; }
  addPoint(x, y);
});

canvas.addEventListener("mousemove", (e) => {
  if (!dragging || !dragTarget) return;
  const {x, y} = getPos(e);
  dragTarget.x = x;
  dragTarget.y = y;
  draw();
  updateCoordPanel();
});

canvas.addEventListener("mouseup", () => {
  dragging = false;
  dragTarget = null;
});

canvas.addEventListener("dblclick", (e) => {
  const {x, y} = getPos(e);
  setSelectedPoint(x, y);
});

canvas.addEventListener("contextmenu", (e) => {
  e.preventDefault();
  const {x, y} = getPos(e);
  deletePoint(x, y);
});

canvas.addEventListener("touchstart", (e) => {
  const {x, y} = getPos(e.touches[0]);
  const now = Date.now();
  if (now - lastTapTime < 300) {
    setSelectedPoint(x, y);
    lastTapTime = 0;
    return;
  }
  lastTapTime = now;

  dragTarget = findPoint(x, y);
  if (dragTarget) dragging = true;
  else longPressTimer = setTimeout(() => deletePoint(x, y), 500);
});

canvas.addEventListener("touchmove", (e) => {
  if (!dragging || !dragTarget) return;
  const {x, y} = getPos(e.touches[0]);
  dragTarget.x = x;
  dragTarget.y = y;
  draw();
  updateCoordPanel();
});

canvas.addEventListener("touchend", (e) => {
  clearTimeout(longPressTimer);
  if (!dragging) {
    const {x, y} = getPos(e.changedTouches[0]);
    addPoint(x, y);
  }
  dragging = false;
  dragTarget = null;
});

// ===== 共通関数 =====
function getPos(e) {
  const rect = canvas.getBoundingClientRect();
  return { x: e.clientX - rect.left, y: e.clientY - rect.top };
}

function findPoint(x, y) {
  for (const p of redPoints) if (dist(p, {x,y}) < 12) return p;
  for (const p of bluePoints) if (dist(p, {x,y}) < 12) return p;
  return null;
}

function addPoint(x, y) {
  if (mode === "red" && redPoints.length < 4) redPoints.push({x,y});
  if (mode === "blue" && bluePoints.length < 4) bluePoints.push({x,y});
  updateCounter();
  draw();
  updateCoordPanel();
}

function deletePoint(x, y) {
  redPoints = redPoints.filter(p => dist(p, {x,y}) >= 12);
  bluePoints = bluePoints.filter(p => dist(p, {x,y}) >= 12);
  updateCounter();
  draw();
  updateCoordPanel();
}

function setSelectedPoint(x, y) {
  for (const p of redPoints) {
    if (dist(p, {x,y}) < 12) {
      selectedPoint = {...p, color:"red"};
      draw();
      updateCoordPanel();
      return;
    }
  }
  for (const p of bluePoints) {
    if (dist(p, {x,y}) < 12) {
      selectedPoint = {...p, color:"blue"};
      draw();
      updateCoordPanel();
      return;
    }
  }
}

function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }

function centroid(list) {
  if (list.length === 0) return null;
  return {
    x: list.reduce((s,p)=>s+p.x,0) / list.length,
    y: list.reduce((s,p)=>s+p.y,0) / list.length
  };
}

function nearest(from, list, excludeSelf=false) {
  let best = null, bestDist = Infinity;
  for (const p of list) {
    if (excludeSelf && p.x === from.x && p.y === from.y) continue;
    const d = dist(from, p);
    if (d < bestDist) { bestDist = d; best = p; }
  }
  return best;
}

function updateCounter() {
  redCount.textContent = redPoints.length;
  blueCount.textContent = bluePoints.length;
  redCount.className = redPoints.length === 4 ? "max" : "";
  blueCount.className = bluePoints.length === 4 ? "max" : "";
}
// ===== 描画 =====
function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(bg, 0, 0, canvas.width, canvas.height);

  // 赤点
  for (let i = 0; i < redPoints.length; i++) {
    const p = redPoints[i];
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.arc(p.x, p.y, 10, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "white";
    ctx.font = "14px sans-serif";
    ctx.fillText(i+1, p.x-4, p.y+5);
  }

  // 青点
  for (let i = 0; i < bluePoints.length; i++) {
    const p = bluePoints[i];
    ctx.fillStyle = "blue";
    ctx.beginPath();
    ctx.arc(p.x, p.y, 10, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "white";
    ctx.font = "14px sans-serif";
    ctx.fillText(i+1, p.x-4, p.y+5);
  }

  const cRed = centroid(redPoints);
  const cBlue = centroid(bluePoints);

  if (cRed) drawCross(cRed.x, cRed.y, 10, "pink");
  if (cBlue) drawCross(cBlue.x, cBlue.y, 10, "lightblue");

  // ===== 機能1（SP用） =====
  if (modeCategory === 1) {

    // 攻撃SP：重心 → 異色の最短点
    if (spMode === "sp_attack") {
      if (cRed) {
        const t = nearest(cRed, bluePoints);
        if (t) {
          drawCircle(t.x, t.y, "pink");
          if (showLines) {
            ctx.strokeStyle = "purple";
            ctx.beginPath();
            ctx.moveTo(cRed.x, cRed.y);
            ctx.lineTo(t.x, t.y);
            ctx.stroke();
          }
        }
      }
      if (cBlue) {
        const t = nearest(cBlue, redPoints);
        if (t) {
          drawCircle(t.x, t.y, "lightblue");
          if (showLines) {
            ctx.strokeStyle = "green";
            ctx.beginPath();
            ctx.moveTo(cBlue.x, cBlue.y);
            ctx.lineTo(t.x, t.y);
            ctx.stroke();
          }
        }
      }
    }

    // バフSP：重心 → 同色の最短点
    if (spMode === "sp_buff") {
      if (cRed) {
        const t = nearest(cRed, redPoints);
        if (t) drawCircle(t.x, t.y, "rgba(255,150,150,0.5)");
      }
      if (cBlue) {
        const t = nearest(cBlue, bluePoints);
        if (t) drawCircle(t.x, t.y, "rgba(100,150,255,0.5)");
      }
    }
  }

  // ===== 機能2（ST用） =====
  if (modeCategory === 2 && selectedPoint) {
    const p = selectedPoint;
    const sameList = p.color === "red" ? redPoints : bluePoints;
    const enemyList = p.color === "red" ? bluePoints : redPoints;

    // バッファー：同色の最寄り点を円で囲む
    if (stMode === "st_buffer") {
      const t = nearest(p, sameList, true);
      if (t) drawCircle(t.x, t.y, "rgba(255,255,0,0.6)");
    }

    // ハナコ（水着）：異色の最寄り点方向に扇形
    if (stMode === "st_hanako") {
      const t = nearest(p, enemyList);
      if (t) {
        const fillColor = p.color === "red"
          ? "rgba(255,0,0,0.3)"
          : "rgba(0,0,255,0.3)";

        const radius = 180;
        const angle = Math.PI / 3;
        const half = angle / 2;

        const baseAngle = Math.atan2(t.y - p.y, t.x - p.x);
        const startAngle = baseAngle - half;
        const endAngle = baseAngle + half;

        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.arc(p.x, p.y, radius, startAngle, endAngle);
        ctx.closePath();
        ctx.fillStyle = fillColor;
        ctx.fill();
      }
    }
  }
}

function drawCross(x, y, size, color) {
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x-size, y-size);
  ctx.lineTo(x+size, y+size);
  ctx.moveTo(x+size, y-size);
  ctx.lineTo(x-size, y+size);
  ctx.stroke();
}

function drawCircle(x, y, color) {
  ctx.strokeStyle = color;
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.arc(x, y, 16, 0, Math.PI*2);
  ctx.stroke();
}

// ===== UIイベント =====

// 機能1・2切り替えボタン
document.getElementById("modeToggle").onclick = () => {
  modeCategory = (modeCategory === 1) ? 2 : 1;

  const btn = document.getElementById("modeToggle");
  const sub = document.getElementById("subSelect");

  sub.innerHTML = "";

  if (modeCategory === 1) {
    btn.textContent = "① SP用";
    sub.appendChild(new Option("攻撃SP", "sp_attack"));
    sub.appendChild(new Option("バフSP", "sp_buff"));
    spMode = "sp_attack";
  } else {
    btn.textContent = "② ST用";
    sub.appendChild(new Option("バフ", "st_buffer"));
    sub.appendChild(new Option("ハナコ（水着）", "st_hanako"));
    stMode = "st_buffer";
  }

  draw();
};

// サブ機能切り替え
document.getElementById("subSelect").onchange = (e) => {
  const v = e.target.value;
  if (v === "sp_attack" || v === "sp_buff") spMode = v;
  if (v === "st_buffer" || v === "st_hanako") stMode = v;
  draw();
};

document.getElementById("toggleColor").onclick = () => {
  mode = (mode === "red") ? "blue" : "red";
  document.getElementById("toggleColor").textContent =
    `現在：${mode === "red" ? "赤" : "青"} → ${mode === "red" ? "青" : "赤"}に切替`;
};

document.getElementById("toggleLine").onclick = () => {
  showLines = !showLines;
  draw();
};

document.getElementById("reset").onclick = () => {
  redPoints = [];
  bluePoints = [];
  selectedPoint = null;
  updateCounter();
  draw();
  updateCoordPanel();
};

document.getElementById("saveImage").onclick = () => {
  const link = document.createElement("a");
  link.download = "tactics.png";
  link.href = canvas.toDataURL("image/png");
  link.click();
};

bg.onload = () => {
  draw();
  updateCoordPanel();
};
</script>

</body>
</html>
